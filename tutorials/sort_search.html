<html>
    <head>
        <title>Julia Xie Portfolio - Sort/Search</title>
        <link rel="stylesheet" type="text/css" href="../main.css">
        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600" rel="stylesheet">
    </head>
    <ul>
        <li><a href="https://julia-xie.github.io">Home</a></li>
        <li><a href="../projects.html">Projects</a></li>
        <li class="dropdown">
            <a class="active" href="../tutorials.html" class="dropbtn">Tutorials</a>
            <div class="dropdown-content">
                <a href="./OOP.html">Object-Oriented Programming (OOP)</a>
                <a href="./arrays.html">Arrays/ArrayLists</a>
                <a href="./sort_search.html">Sort/Search</a>
                <a href="./recursion.html">Recursion</a>
            </div>
        </li>
        <li><a href="../contact.html">Contact</a></li>
        <li><a href="../about.html">About</a></li>
        <li><a href="../bibliography.html">Bibliography</a></li>
    </ul>
    <br>
    <h2>Tutorials</h2>
    <h3>Sort/Search</h3>
    <div class="tutorials">
        <p2>
            <p>
                The following tutorial deals with the manipulation of arrays or ArrayLists.
                <br>
                To learn more about arrays, click <l><a href="arrays.html">here</a></l>.
            </p>
            <p>
                Sorting and searching are the main ways to manipulate an array to make it easier to work with.
                There are many ways to both search and sort, each of them slightly different in their efficiency.
            </p>
            <h4>
                Sorting
            </h4>
            <p>
                An array of elements can be sorted in ascending or descending order, depending on how it is needed.
                For the most part, numerical data and primitive data types are sorted the most frequently.
                Objects are able to be sorted, however, it may not work as intended all the time.
            </p>
            <p>
                There are many different sorts that can be used to sort an array.
                These include bubble sort, insertion sort, merge sort, and many more.
            </p>
            <p>
                <i>Bubble sorting</i> is essentially looping through the array of elements and seeing if each element is greater (or less than depending on what order is desired) than the one in front of it.
                If so, then the two elements are swapped and this process is repeated until the entire array is sorted.
            </p>
            <p>
                <i>Insertion sorting</i> is when an array is looped through and every element is inserted into the correct spot in the array.
            </p>
            <p>
                <i>Merge sorting</i> is splitting the array into many different sorted arrays (i.e. arrays with one element) and then merging them all to form one sorted array.
            </p>
            <p>
                This tutorial will go in depth about a sorting algorithm called <i>selection sort</i>, which is quite similar to insertion sort.
            </p>
            <h5>
                Selection Sort
            </h5>
            <p>
                Selection sort is one of the sorting algorithms which are pretty easy to implement, along with bubble sort and insertion sort.
                In a nutshell, what happens during selection sort is that the array of elements is looped through, and the smallest (or greatest) element is found.
                Then, that element is swapped with the first element of the unsorted portion of the array, and this process continues until the entire array is sorted.
            </p>
            <p>
                Let's take that step by step:
            </p>
            <p>
                First, let's create the unsorted array.
                This array can be randomly generated or from user input, but for the sake of simplicity, let's create it ourselves:
            </p>
            <pre>
    <b>int arr [] = {6, 3, 7, 4, 1, 2, 0, 8, 9, 5};</b>
            </pre>
            <p>
                Next, we need a for loop:
            </p>
            <pre>
    int arr [] = {6, 3, 7, 4, 1, 2, 0, 8, 9, 5};
    <b>for (int i = 0 ; i < arr.length - 1 ; i++) {
        ...
    }</b>
            </pre>
            <p>
                This for loop runs from the first index of the array (i.e. 0) to the second to last index of the array (i.e. arr.length - 1).
                This loop denotes how much of the array is sorted, as the index keeps moving up every time.
                The reason it runs until second to last index instead of the very last index is that it needs to compare the elements in the unsorted portion of the array, which are the elements from index <code>i</code> and the elements after it.
                It is not necessary to run until the last index because it would only be comparing one element against itself, which means the array would already be sorted at that point.
            </p>
            <p>
                Now, we need a variable which will hold the index of the element which has the minimum value (or maximum value if sorting in descending order):
            </p>
            <pre>
    int arr [] = {6, 3, 7, 4, 1, 2, 0, 8, 9, 5};
    for (int i = 0 ; i < arr.length - 1 ; i++) {
        <b>int min = i;</b>
        ...
    }
            </pre>
            <p>
                The reason it is set to the variable <code>i</code> is because that is the index of the start of the unsorted portion of the array.
            </p>
            <p>
                Next, we need another for loop, which runs inside the other for loop:
            </p>
            <pre>
    int arr [] = {6, 3, 7, 4, 1, 2, 0, 8, 9, 5};
    for (int i = 0 ; i < arr.length - 1 ; i++) {
        int min = i;
        <b>for (int j = i + 1 ; j < arr.length ; j++) {
            ...
        }</b>
        ...
    }
            </pre>
            <p>
                This for loop runs through the unsorted portion of the array, not including the very first element.
                The very first element is not needed because its index is already held in the <code>min</code> variable.
            </p>
            <p>
                Next up is the if statement which compares the element at index <code>j</code> to the minimum value at index <code>min</code>:
            </p>
            <pre>
    int arr [] = {6, 3, 7, 4, 1, 2, 0, 8, 9, 5};
    for (int i = 0 ; i < arr.length - 1 ; i++) {
        int min = i;
        for (int j = i + 1 ; j < arr.length ; j++) {
            <b>if (arr[j] < arr[min]){
                ...
            }</b>
        }
        ...
    }
            </pre>
            <p>
                The if statement checks if the element at index <code>j</code> is less than the current minimum value.
                If this algorithm were sorting in descending order, it would check if the element was greater than the maximum value.
            </p>
            <p>
                Next, we need to set the index of the element with the minimum value to the current index:
            </p>
            <pre>
    int arr [] = {6, 3, 7, 4, 1, 2, 0, 8, 9, 5};
    for (int i = 0 ; i < arr.length - 1 ; i++) {
        int min = i;
        for (int j = i + 1 ; j < arr.length ; j++) {
            if (arr[j] < arr[min]){
                <b>min = j;</b>
            }
        }
        ...
    }
            </pre>
            <p>
                If the element is less than the minimum value, then the index of the minimum value would be set to the index of the current element.
                This comparison is repeated until the for loop is finished and every element in the unsorted portion of the array is checked.
            </p>
            <p>
                Now, we need to swap the element with the minimum value with the first element of the unsorted portion of the array.
                We can do this with the help of a temporary variable:
            </p>
            <pre>
    int arr [] = {6, 3, 7, 4, 1, 2, 0, 8, 9, 5};
    for (int i = 0 ; i < arr.length - 1 ; i++) {
        int min = i;
        for (int j = i + 1 ; j < arr.length ; j++) {
            if (arr[j] < arr[min]){
                min = j;
            }
        }
        <b>int temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;</b>
    }
            </pre>
            <p>
                The temporary variable is used to hold the minimum value as that index is being replaced with the first element of the unsorted portion.
                Without the variable, there would be no way to swap the elements without losing one of them.
            </p>
            <p>
                The sort is now complete!
                If one were to print out the array every time an element was swapped, it would look like:
            </p>
            <pre>
    6 3 7 4 1 2 0 8 9 5
    0 3 7 4 1 2 6 8 9 5
    0 1 7 4 3 2 6 8 9 5
    0 1 2 4 3 7 6 8 9 5
    0 1 2 3 4 7 6 8 9 5
    0 1 2 3 4 7 6 8 9 5
    0 1 2 3 4 5 6 8 9 7
    0 1 2 3 4 5 6 8 9 7
    0 1 2 3 4 5 6 7 9 8
    0 1 2 3 4 5 6 7 8 9
            </pre>
            <p>
                Let's add some square brackets to denote the unsorted portion:
            </p>
            <pre>
    [6 3 7 4 1 2 0 8 9 5]
    0 [3 7 4 1 2 6 8 9 5]
    0 1 [7 4 3 2 6 8 9 5]
    0 1 2 [4 3 7 6 8 9 5]
    0 1 2 3 [4 7 6 8 9 5]
    0 1 2 3 4 [7 6 8 9 5]
    0 1 2 3 4 5 [6 8 9 7]
    0 1 2 3 4 5 6 [8 9 7]
    0 1 2 3 4 5 6 7 [9 8]
    0 1 2 3 4 5 6 7 8 [9]
            </pre>
            <p>
                As you can see, each of the smallest elements is swapped with the first element of the unsorted portion (the elements in the square brackets).
                First, the 0 is swapped with the 6, then the 1 is swapped with the 3, then the 2 is swapped with the 7, and so on.
                This process repeats until the maximum value is left in the unsorted portion, at which point the entire array is sorted.
            </p>
            <h4>
                Efficiency and Big O Notation
            </h4>
            <p>
                Not all sorting algorithms are made the same.
                Some algorithms are faster with a smaller number of elements, and some are faster with a larger number of elements.
                A way to portray the time complexity of a sorting algorithm is something called <i>big O notation</i>.
            </p>
            <p>
                Big O notation is based on <i>n</i>, the number of elements in an array.
                For example, O(n) is a linear time complexity, and the number of operations that need to be done is equal to n.
                O(n^2) is a quadratic time complexity, and the number of operations that need to be done is equal to n^2.
                So, if an array has only one element, an algorithm with a time complexity of O(n) and an algorithm with a time complexity of O(n^2) would be the same efficiency.
                This is because since n is equal to 1, n^2 is equal to 1^2 and both are equal to 1.
                However, as there are more and more elements, an algorithm with a time complexity of O(n^2) would be much slower than one with a time complexity of O(n).
                For example, when sorting an array with 21 elements, an algorithm with a time complexity of O(n) would have to make 21 operations, while an algorithm with a time complexity of O(n^2) would have to do 441 operations.
            </p>
            <h5>
                Best Case, Worst Case, and Average Case
            </h5>
            <p>
                Every sorting algorithm has a best case time complexity, a worst case time complexity, and an average case time complexity.
                For example, selection sort's best case, worst case, and average are all O(n^2).
                This means that selection sort is considered a very slow sorting algorithm.
                The reason that all of selection sort's cases are the same time complexity is that even if it is given an already sorted array, it still has to compare all of its elements.
            </p>
            <p>
                From fastest to slowest, here are the time complexities in big O notation:
            </p>
            <p>
                O(1) - constant
                <br>
                O(log n) - logarithmic
                <br>
                O(n) - linear
                <br>
                O(n log n) - linearithmic
                <br>
                O(n^2) - quadratic
                <br>
                O(2^n) - exponential
                <br>
                O(n!) - factorial
            </p>
            <p>
                Here are the best case, worst case, and average case time complexities for the most popular sorting algorithms:
            </p>
            <table>
                <tr>
                    <th>Sorting Algorithm</th>
                    <th>Best Case</th>
                    <th>Worst Case</th>
                    <th>Average Case</th>
                </tr>
                <tr>
                    <td>Selection Sort</td>
                    <td>O(n^2)</td>
                    <td>O(n^2)</td>
                    <td>O(n^2)</td>
                </tr>
                <tr>
                    <td>Bubble Sort</td>
                    <td>O(n)</td>
                    <td>O(n^2)</td>
                    <td>O(n^2)</td>
                </tr>
                <tr>
                    <td>Insertion Sort</td>
                    <td>O(n)</td>
                    <td>O(n^2)</td>
                    <td>O(n^2)</td>
                </tr>
                <tr>
                    <td>Heap Sort</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                </tr>
                <tr>
                    <td>Quick Sort</td>
                    <td>O(n log n)</td>
                    <td>O(n^2)</td>
                    <td>O(n log n)</td>
                </tr>
                <tr>
                    <td>Merge Sort</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                </tr>
            </table>
            <p>
                Generally, the algorithms which are simpler to implement tend to be slower than those which are more difficult to implement.
            </p>
            <h4>
                Searching
            </h4>
            <p>
                To search for an element in an array, one needs to use a sorting algorithm.
                The two main sorting algorithms are <i>sequential search</i> and <i>binary search</i>.
            </p>
            <h5>
                Sequential Search
            </h5>
            <p>
                Sequential search (also known as linear search) is the most simple and basic way to search for an element in an array.
                It involves looping through the array once and comparing all the elements until it is found.
            </p>
            <p>
                Here is a simple implementation of sequential search:
            </p>
            <pre>
    public int sequentialSearch(int [] arr, int target) {
        for (int i = 0 ; i < arr.length ; i++) {
            if (arr[i] == target) {
                // returns the index of the element
                return i;
            }
        }
        // returns -1 if it is not found
        return -1;
    }
            </pre>
            <p>
                In the above implementation, the method has two parameters, the array, and the value that is being searched for.
                There is a for loop which runs through the array once, and it compares the current element with the target.
                If the element is found, the index of the array is returned.
                If the element is not found, the method returns -1.
            </p>
            <h5>
                Binary Search
            </h5>
            <p>
                Binary search is more complicated than sequential search, but it is generally faster.
                However, the algorithm involves having to sort the array first.
            </p>
            <p>
                How the algorithm works is that first, it compares the element in the very middle of the array to the target.
                If the target is less than the found element, it narrows its search range to the lower half of the array if it is sorted in ascending order, or the upper half if it is sorted in descending order.
                This process continues until the element is found.
            </p>
            <p>
                The best way to implement binary search is to do it recursively.
                <br>
                To learn more about recursion, click <l><a href="recursion.html">here</a></l>.
            </p>
            <p>
                A recursive binary search method would keep splitting the array is half until the element is either found or when the array only contains one element which is not equal to the target.
            </p>
            <p>
                This is an example of a recursive binary search method:
            </p>
            <pre>
    public int binarySearch(int [] arr, int srt, int end, int tar) {
        if (start <= end) {
            // the middle index
            int mid = (srt + end) / 2;

            // if the element from the middle index is equal to the
            // target then return the index
            if (tar == arr[mid])
                return mid;

            // if the element from the middle index is smaller than
            // the target then it is in the lower half
            if (tar < arr[mid])
                return binarySearch(arr, srt, mid - 1, tar);

            // if the element from the middle index is greater than
            // the target then it is in the upper half
            return binarySearch(arr, mid + 1, end, tar);
        }

        // if the target is not found
        return -1;
    }

            </pre>
            <p>
                In this method, there are 4 parameters, the array sorted in ascending order, the start of the section which needs to be searched, the end of the section which needs to be searched, and the target value which is to be searched for.
                First, the method checks if the start index is smaller than or equal to the end index.
                If it is not, that means that the entire array has been searched and the target value is not found in the array.
                In this case, the method would return -1.
                If it is, then a new variable is declared which denotes the middle between the start and end indices.
                Then, it checks if the target is equal to the element at middle index.
                If it is, then the middle index is returned.
                If it is smaller than the element at the middle index, the method is called again, with the start index staying the same and the end index being the middle index minus 1.
                If it is greater than the element at the middle index, the method is called again, but this time the start index is the middle index plus one, and the end index stays the same.
            </p>
            <p>
                The method recursively calls itself until the element is found, or the array has been searched and the element is not in the array.
            </p>
            <p>
                While binary search can be done recursively, it can also be done iteratively using a while loop.
            </p>
            <p>
                Here is implementation of an iterative solution to binary search:
            </p>
            <pre>
    public int binarySearch (int [] arr, int tar) {
        int start = 0;
        int end = arr.length - 1;

        // while loop runs as long as the start index is smaller
        // than or equal to the end index
        while (start <= end) {
            // the middle index
            int mid = (start + end) / 2;

            // if the element from the middle index is equal to the
            // target then return the index
            if (tar == arr[mid)
                return mid;

            // if the element from the middle index is smaller than
            // the target then it is in the lower half
            else if (tar < arr[mid])
                end = mid - 1;

            // if the element from the middle index is greater than
            // the target then it is in the upper half
            else
                start = mid + 1;
        }

        // if the target is not found
        return -1;
    }
            </pre>
            <p>
                When done iteratively, the while loop keeps running until the target is either found or the start index becomes greater than the end index.
                If the target is smaller than the element at the middle index, the end index becomes the middle index minus 1.
                If the target is greater than the element at the middle index, the start index becomes the middle index plus 1.
                Everything else is basically the same as the recursive solution.
            </p>
            <h5>
                Time Complexity
            </h5>
            <p>
                Like sorting algorithms, searching algorithms also have a time complexity.
            </p>
            <p>
                Here are the best case, worst case, and average case time complexities for sequential search and binary search.
            </p>
            <table>
                <tr>
                    <th>Searching Algorithm</th>
                    <th>Best Case</th>
                    <th>Worst Case</th>
                    <th>Average Case</th>
                </tr>
                <tr>
                    <td>Sequential Search</td>
                    <td>O(1)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>Binary Search</td>
                    <td>O(1)</td>
                    <td>O(log n)</td>
                    <td>O(log n)</td>
                </tr>
            </table>
            <p>
                For both algorithms, the best case is when the element is found on the first try.
            </p>
            <p>
                Also, while binary search is faster than sequential search, keep in mind that binary search only works for sorted arrays.
                To search for an element in an unsorted array, it would be faster just to use sequential search than to sort the array and then use binary search.
            </p>
        </p2>
    </div>
</html>
